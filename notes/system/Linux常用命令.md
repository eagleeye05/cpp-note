> 参考
>
> - aking-note
> - linw7的github

[TOC]

# 一.文件管理

## 1. 文件查找：find

**使用方法**

```bash
find [查找目录] [查找条件]

查找目录：
	.：在当前目录及子目录下查找
	A：在目录A及A的子目录下查找
查找条件：
	-name：根据文件名查找
	-regex：根据正则表达式查找
	-type：按类型查找（f：文件，d：目录，l：链接...）
	-atime：按访问时间查找（n：n天前的一天内，+n：n天前（不含n天本身），-n：n天内（不含n天本身）
	-mtime：按修改时间查找（n：n天前的一天内，+n：n天前（不含n天本身），-n：n天内（不含n天本身）
	-size：按大小查找（单位k，+nk:"比nk更大"，-nk:"比nk更小"）
	-perm：按权限查找（644：权限等于644的文件）
	-user/-nouser：用户名等于/用户名不等于
	-group/-nogroup：组名等于/组名不等于
```

**示例**

```bash
#1.在当前目录及子目录查找后缀为.cpp的文件
find . -name *.cpp
#2.使用正则表达式查找
find . -regex ".*.cpp$"
```

## 2. 文件拷贝：cp

**使用方法**

```bash
cp [选项] 原路径 目的路径
选项：
	-a：将所有属性一起复制（包括拥有者、时间等信息）
	-i：目标存在时，进行询问
	-r：递归复制
```

## 3. 打包解包：tar

**使用方法**

```bash
tar [-j|-z] [cv] [-f 压缩包名] 目录
tar [-j|-z] [xv] [-f 解压包名] [-C 解压路径]
选项：
	-c/-x：打包/解包
	-j/-z：bzip2格式/gzip格式
	-v：显示过程
```

# 二.文件处理

## 1.（显示行号）查看文件：nl

行号计算不包括空行

## 2. 文本查找：grep

**使用方法**

```bash
grep [选项] 模式串 文件
输出 | grep [选项] 模式串

选项
	-e：使用多个模式串
	-i：忽略大小写
	-n：打印行号
	-c：统计次数（一行算一次） 
```

**示例**

```bash	
#1.在test.c中搜索包含字符串“printf”或“count”的行
grep -e “printf" -e "count" test.c
```

## 3. 排序：sort

**使用方法**

```bash
sort [选项] 文件
输出 | sort [选项]

选项：
	-d：按字典排序
	-n：按数字排序
	-k："-k n"表示各行按第n列排序
	-r：反序
```



## 4. 转换：tr

**使用方法**

```bash
#set1、set2为字符集，可以使单个字符，也可以是字符串
输出 | tr [选项] set1 set2

选项：
	-d：删除字符
	-s：字符压缩
```

**示例**

```bash
#1.删除字符':'
cat /etc/passwd | tr -d ':'

#2.将小写字母替换成大写字母
last | tr '[a-z]' 'A-Z' 

#3.将'a','b','c'替换为'z'
cat test | tr "abc" 'z'

#4.将连续的'a'压缩为'b'（单个或连续出现多个'a'会压缩为一个'b'
cat test | tr -s 'a' 'b'
```

## 5. 切分文本：cut

**使用方法**

```Bash
cut [选项] 文件
输出 | cut [选项]

选项：
	-d：分隔符（-d ':' 以‘：’为分隔符）
	-f：选择域（-f 1,2 输出分割后第1列和第2列）
	-c：字符范围（-c n-m 输出第n到m个字符。如果没有m，输出到末尾）
```

**示例**

```bash
#1.按':'分割$PATH，输出第3个和第5个
echo $PATH | cut -d ':' -f 3,5

#2.输出export运行结果每行的第12-20字符
export | cut -c 12-20
```

## 6. 拼接文本：paste

**使用方法**

```bash
paste [选项] file1 file2

选项：
	-d：指定拼接时使用的分隔符（默认使用tab作为分隔符）
```

## 7. 统计：wc

**使用方法**

```bash
wc [选项] 文件
输出 | wc [选项]

选项:
	-c：统计字符数
	-w：统计单词数
	-l：统计行数
```

## 8. 数据处理

sed常用于一整行的处理。如果有100万行的文件，要在第100行加某些文字，此时由于文件太大，不适合于vim处理。因此使用sed是个很好的选择

**使用方法**

```bash
sed [选项] '[动作]' 文件
输入 | sed [选项] '[动作]'

选项：
	-n：安静模式，只输出sed处理过的行（否则未处理的行也会输出）
	-i：结果直接作用到文件（没指定时不会修改文件）
	-e：在命令行模式输入动作
	-f：从文件读取动作
	
动作：[n1[,n2]] function
function：
	a/i：在后插入/在前插入
	d：删除
	p：打印
	s：替换
```

**示例**

```bash
#1.插入
nl /etc/passwd | sed '2a drink tea' #在第2行后插入一行：“drink tea”
nl /etc/passwd | sed '2a aaa \
> bbb' #在第2行后插入两行：“aaa”和“bbb”

#2.删除
nl /etc/passwd | sed '2,5d' #删除2-5行
sed '/^$/d' ip #将ip文件中的空行删除

#3.打印2-5行（安静模式，不使用安静模式2-5行会打印两次）
nl /etc/passwd | sed -n '2,5p'

#4.替换
nl /etc/passwd | sed '2s/daemon/root/g' #将第二行的daemon替换成root
ifconfig | grep 'inet addr' | sed 's/^.*addr://g' #将所有开头的“inet addr:”删除
```

## 9. 数据处理：awk

相比sed常用于一整行的处理，awk则比较倾向于将一行分成数个“字段”来处理。因此，相当适合小型的数据处理

**awk处理步骤：**

1. 读入第一行，并将第一行的数据填入到$0,$1,$2等变量中
2. 依据条件类型的限制，判断是否需要进行后面的动作
3. 做完所有的动作和条件类型
4. 若还有后续的“行”的数据，则重复1-3步，直到所有的数据读完为止

**使用方法**

```bash
awk '条件类型1{动作1} 条件类型2{动作2}...' filename
输出 | awk '条件类型1{动作1} 条件类型2{动作2}...'

变量：
	$0：整行
	$1：按分隔符分割后额第1列
	$2：按分隔符分割后的第2列
	$k：按分隔符分割后的第k列
	NF：每一行拥有的字段数
	NR：目前所处理的行数
	FS：目前的分割字符（默认空格或tab）
条件判断：>,<,>=,<=,==,!=
命令分隔：使用';'或Enter
```

**示例**

```bash
#1.打印last -n 5结果中的每行经过分隔符（默认情况下为空格或tab）分隔后的第1列和第3列
last -n 5 | awk '{print $1 "\t" $3}'

#2.以':'作为分隔符，打印第3列小于10的所有行的第1列和第3列
cat /etc/passwd | awk '{FS=":"} $3<10{print $1 "\t" $3}' #第一行不会处理
cat /etc/passwd | awk 'BEGIN{FS=":"} $3<10{print $1 "\t" $3}' #第一行会处理

#3.假设test文件由3列数字组成，以空格分隔。该命令会计算每行的和然后打印
awk '{total=$1+$2+$3;printf "%10d %10d %10d %10.2f\n",$1,$2,$3,total}' test
```

注意上面的示例2，awk首先是读取一行，分隔后的数据填入$0,$1,$2等变量中才开始进行条件判断和执行动作。因此第一条命令在按空格或tab分隔后才将分隔符换成':'，所以第一行显示结果不对