# 42-连续子数组的最大和 

#### 题目描述

HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1)

**思路分析1：**

对数组{6,-3,-2,7,-15,1,2,2}进行如表所示的操作

| 序号 |              操作              | 累加的子数组和 | 最大的子数组和 |
| :--: | :----------------------------: | :------------: | :------------: |
|  1   |               +6               |       6        |       6        |
|  2   |               -3               |       3        |       6        |
|  3   |               -2               |       1        |       6        |
|  4   |               +7               |       8        |       8        |
|  5   |              -15               |       -7       |       8        |
|  6   | 抛弃-15之前的数，将累加和设为1 |       1        |       8        |
|  7   |               +2               |       3        |       8        |
|  8   |               +2               |       5        |       8        |

总结如下：

- 1.假设数组为array，设一个current指向目前遍历的数字的位置，一个sum用于存放子数组和，一个max用于存放最大值

- 2.在遍历下一个数时，先检查sum是否小于0，

  - 如果小于0，则将start设为current，sum设为array[current]，判断是否需要更新max，current指向下一个数。

  - 否则sum加array[current]，判断是否需要更新max，current指向下一个数。

    由2不断重复，直至将数组遍历完毕。
  
  **注意：**max必须设为一个int所能表示的最小值，对于64位的机器，int为4字节，即32位，所能表示的最小值为0x80000000，为补码表示，表示最小负数，比正数多表示一个
  
  具体为0x180000000（33位原码）-》0x17fffffff（33位返码）-》0x80000000(32位补码)

**思路分析2：**

应用动态规划法

设函数f(i)为以第i个数字结尾的子数组的最大和，那么需要求max[f(i)]，其中0<=i<n，有：

f(i)=

- array[i],  i==0或者f(i-1)<=0

- f(i-1)+array[i],   i!=0并且f(i-1)>0

	代码与方法一一致，递归分析，循环编码。

**具体实现：**

```c++
class Solution {
public:
    int FindGreatestSumOfSubArray(vector<int> array) {
        if(array.empty()) return 0;
        int maxVal = INT_MIN;
        int curSum = array[0];
        for(int i = 1; i < array.size(); i++){
            if(curSum > 0){
                curSum += array[i];
            }
            else{
                curSum = array[i];
            }
            maxVal = max(maxVal, curSum);
        }
        return maxVal;
    }
};
```

注：有时需要区分是不合理输入造成返回值为0，还是最小值就是为0，这时可以设置一个标志位。