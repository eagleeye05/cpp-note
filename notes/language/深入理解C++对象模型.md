# 深入探索C++对象模型

[TOC]

## 第1章 关于对象

C++在布局以及存取时间上的主要额外负担有virtual引起的：

- 虚函数机制：用以支持一个有效率的”执行期绑定“
- 虚基类：用以实现“多次出现在继承体系中的base class，有一个单一而被共享的实例

### 1.1 C++对象模型

成员分类：

数据成员：static、non-static

成员函数：static、non-static、virtual

![image-20200412205149295](../../pics/image-20200412205149295.png)

每个类有一堆指向虚函数的指针，存放在表格中，这个表格称为**虚函数表**（vtbl），虚函数表的第一个slot中存放的是type_info object，用于动态绑定时的类型识别，支持runtime type identification，RTTI，通常存放在表格的第一个slot

该模型的优点：

- 空间和存取时间效率高

该模型的缺点：

- 类对象的非静态数据成员改变，需要重新编译

**成员，函数放置的位置**：

- 在类对象中：
  - 1.non-static数据对象在每个类对象中
  - 2.**虚函数指针（vptr）**：指向类的虚函数表，其设定和重置由类的构造函数，析构函数和拷贝赋值运算符自动完成
  - 3.**虚基指针（bptr）**：如果有虚继承的话，在**3.4**节深入讨论
- 在对象之外：
  - 1.虚函数表
  - 2.虚基类表
  - 非虚函数：包括static，non-static
  - 静态数据成员

<img src="../../pics/image-20200412210125191.png" alt="image-20200412210125191" style="zoom:67%;" />

在**虚拟继承**情况下，base class不管在继承串链中被派生多少次，永远只会存在一个实例；但是在普通继承下，则会存在**多个实例**

- 优点：
  - 每一个class object中对于继承都有一致的表现方式：每个class object都应该在固定的位置上安放一个base table指针，与base classes的大小和个数无关
  - 无需更改class objects本身，就可以放大缩小，或更改base class table

### 1.3 对象的差异

C++的多态只存在于一个个的public class继承体系中，以以下方法支持多态：

- 1.经由一组隐式的转化操作：把一个派生类的指针转化为一个指向public继承的基类指针
  - `shape *ps = new circle();`
- 2.经由虚函数机制
  - `ps->rotate();`
- 3.经由dynamic_cast和typeid运算符
  - `if( circle *pc = dynamic_cast<circle*>( ps ) )...`

多态的**主要用途**：经由一个共同的接口来影响类的封装，这个接口通常被定义在一个抽象的base class中

**sizeof一个类对象时需要考虑的部分：**

- 1.其non-static数据成员的总和
- 2.对齐导致填补的空间
- 3.支持虚函数和虚基类的指针

**类对象的布局：**

```c++
class ZooAnimal{
public:
    ZooAnimal();
    virtual ~ZooAnimal();
    virtual void rotate();
    
protected:
    int loc;
    string name;
};

ZooAnimal za( "Zoey" );
ZooAnimal *pza = &za;
```

za和pza的可能布局（注意string类型，string所存字符串长度与sizeof(对象)无关）：

![](../../pics/Pic_1_4_%E7%8B%AC%E7%AB%8Bclass%E7%9A%84object%E5%B8%83%E5%B1%80%E5%92%8Cpointer%E5%B8%83%E5%B1%80.png)

如果string的布局是按图所示，则==sizeof(ZooAnimal)==16字节（4+8+4），假定string是传统的8byte

- 但自己VS上测试的结果不一致
  - sizeof(stirng)==28
  - sizeof(za)==sizeof(ZooAnimal)==28+4+4==36
  - string vector的sizeof与个数无关，为固定大小，具体由编译器决定
- 转换（cast）其实是一种编译器指令，大部分情况下并不改变一个指针所含的真正地址，它只影响“被指出内存的大小和其内容”的解释方式

#### 1.3.1 指针的类型

“指针类型”的作用：告诉编译器如何解释某个特定地址中的内存内容及其大小

#### 1.3.2 加上多态之后

```c++
class bear : public ZoonAnimal {
public:
    Bear();
    ~Bear();
    void rotate();
    virtual void dance();
protected:
    enum Dance {...};
    
    Dance dances_know;
    int cell_block;
};

Bear b("Yogi");
Bear *pd = &b;
Bear &rb = *pb;
```

- 注意enum类型的布局

![image-20200412214513211](../../pics/image-20200412214513211.png)

```c++
Bear b;
ZooAnimal *pz = &b;
Bear *pb = &b;
```

**pz与pb的区别是：**

- 它们都指向Bear object的第一个byte

- pb所涵盖的地址包含整个Bear对象
- pz所涵盖的地址只包含Bear对象中的ZooAnimal子对象
- **不能通过pz来处理Bear的任何members，唯一的例外是通过虚函数**

## 第2章 构造函数语意学

#### 2.1 默认构造函数构造操作

会自动合成默认构造函数的情况：

- ==1.该类中有类成员，且该类成员有默认构造函数==

  因为：该类需要调用类成员的默认构造函数来初始化类成员，因此必须生成一个该类的默认构造函数，但该类的默认构造函数不会初始化该类的其他没有默认构造函数的类成员或内置类型成员

其他相关知识点：

- 1). 如果一个类A内含一个或一个以上的类成员对象，那么由程序员显示定义的构造函数即使没有显示调用类成员对象的构造函数，A的显示声明的构造函数也会隐式地调用类成员的默认构造函数（这些隐式调用在初始化列表==执行之前发生==）
- 2). 如1).中的情况，如果有多个类成员，那么调用它们默认构造函数的顺序与==声明顺序一致==。

```c++
//1) 2)例子
class Dopey { public: Dopey(); ... };
class Sneezy { public: Sneezy( int ); Sneezy(); ... };
class Bashful { public: Bashful(); ... };

class Snow_White {
public:
    Dopey dopey;
    Sneezy sneezy;
    Bashful bashful;
private:
    int mumble;
};

//Snow_White的显示构造函数
Snow_White::Snow_White : sneezy(1024)
{
    mumble = 1024;
}

//Snow_White的显示构造函数实际上会发生
Snow_White::Snow_White : sneezy(1024)
{
    dopey.Dopey::Dopey();
    sneezy.Sneezy::Sneezy(1024);
    bashful.Bashful::Bashful();
    
    mumble = 1024;
}
```

- 2.该类成员继承于有默认构造函数的基类

原因：该类需要调用基类的默认构造函数，因此编译器会为其合成一个默认的构造函数。如果有多个基类，==调用顺序和基类顺序一致==

相关知识点：

​		1）如果该类声明了别的构造函数，但是没有默认构造函数，别的构造函数会隐式的调用基类的默认构造函数。此时不会合成默认构造函数。

​		2）如果同时存在有默认构造函数的基类和有默认构造函数的类成员对象，那么先调用基类的默认构造函数，再调用类成员对象的默认构造函数

- 3.该类有虚功能（虚函数或虚基类）

有虚功能的情况：

​		1）类声明（或基层）了一个函数

​		2）类派生子一个继承串链，其中有一个或多个虚基类

原因：该类需要默认构造函数为每个对象初始化虚函数表指针和虚基类指针

相关知识点：

​		1）如果该类有程序员定义的显示构造函数，这些构造函数==会隐式完成虚函数指针和虚基类指针==的初始化工作

**总结**

- 1.除了以上提出的3种情况（实际上是4种），编译器不会为一个类合成默认构造函数
- 2.在合成的默认构造函数中，只有有默认构造函数的基类的子对象和有默认构造函数的类成员对象会被初始化，其他非静态成员都不会被初始化（包括整数、整数指针、整数数组等）
- 3.常见误解：
  - 任何class如果没有定义默认构造函数，都会被合成一个（错误！）
  - 合成的默认构造函数会显示设定类内每一个数据成员的默认值（错误！）

### 2.2 拷贝构造函数的操作

以一个类对象作为另一个对象的初值的情况有三种：

- 1.对一个对象显示的初始化操作：`X xx = x;`
- 2.对象被当做参数交给某个函数：`foo(xx);`
- 3.函数传回一个类对象：`X foo(){ X xx; return xx; }`

上述三种情况，会导致构造函数的调用，有可能发生以下三种情况：

- 一个临时类对象的产生
- 导致程序代码的脱变
- 或以上两种都有

**bitwise copy semantics**：位逐次拷贝语意

**bitwise copy**：将源对象中的成员变量中的每一位赋值到目标对象中。例如指针类型，只将源对象的指针中所存放的地址复制到目标指针的地址中，它们指向的其实是同一块内存地址空间。这会出现重复释放同一内存空间等问题

如果类中出现了**位逐次拷贝语意**，默认构造函数和默认拷贝构造函数就不会被合成，此时类的产生由**位逐次拷贝**完成

不展现**位逐次拷贝语意**的情况（与默认构造函数的情况是一样的）：

- 1.当类包含一个成员对象，该成员对象拥有一个拷贝构造函数（显示声明的拷贝构造函数或编译器合成的拷贝构造函数都可以）
  - 当前类合成的拷贝构造函数会自动调用该成员对象的拷贝构造函数
- 2.当class继承自一个基类，而该基类拥有一个拷贝构造函数（显示或合成）
  - 当前类合成的拷贝构造函数会自动调用该基类的拷贝构造函数
- 3.拥有虚功能时
  - 该类声明了一个或多个虚函数
    - 需要重新设定虚函数表的指针
  - 该类派生自一个继承串链，其中有一个或多个虚基类
    - 需要处理虚基类子对象


**重新设定虚函数表的指针**

当一个类声明了一个或多个虚函数，编译器会有如下操作：

- 1.为这个类增加一个虚函数表，表中含有每一个有作用的虚函数的地址
- 2.生成一个该类对象时，每个对象都有一个指向1.中虚函数表的指针

因为当一个类有虚函数、类对象有虚函数表指针时，编译器需要为其初始化，因此这样的类不再有“位逐次拷贝语意”，因此编译器需要合成一个拷贝构造函数

如果在有虚函数的情况下

- 当一个类对象以其派生类的某个对象作为初值时，使用“位逐次拷贝”，会出错
- 当一个类对象用另一个该类对象作为初值时，使用“位逐次拷贝”，不会出错
- 因此，问题只存在于“当一个类对象以其派生类的某个对象作为初值时”

有虚函数的情况下，使用“位逐次拷贝”和合成拷贝构造函数的区别：

- 位逐次拷贝方式：franny的==虚函数表指针指向yogi所属类Bear的虚函数表==
- 合成拷贝构造函数方式：franny虚函数表指针指向franny所属类==ZooAnimal的虚函数表==

```c++
//Bear继承自ZooAnimal
Bear yogi;
ZooAnimal franny = yogi; //这里会发生切割行为
```

![](../../pics/%E4%BD%8D%E9%80%90%E6%AC%A1%E6%8B%B7%E8%B4%9D%E5%92%8C%E5%90%88%E6%88%90%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB.png)

**处理虚基类子对象**

有虚基类的情况下，当一个类对象以其派生类的某个对象作为初值时，使用“位逐次拷贝”，会出错。

例如：

![](../../pics/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0_%E8%99%9A%E5%9F%BA%E7%B1%BB.png)

```c++
RedPanda little_red;
Raccoon little_critter = litter_red;
```

在这种情况下，为了完成正确的little_critter初值设定，编译器必须合成一个拷贝构造函数

合成构造函数需要做的：

- 1.设定虚基类指针/偏移量
- 2.对每一个成员指向不要的成员初始化操作
- 3.其他内存相关工作（3.4章节有关于虚基类有更详细的讨论）

当使用基类指针所指向的对象给基类对象赋值时，编译器无法知道“位逐次拷贝语意”是否还保持着，因为它无法知道基类指针是指向一个派生类对象还是基类对象，这种情况下，位逐次拷贝可能够用，可能不够**用**

```c++
//位逐次拷贝可能够用，可能不够用
Raccoon *ptr;
Raccoon little_critle = *ptr;
```

### 2.3 程序转化语意学